# 类文件结构

## JVM 的无关性

- 平台无关性：任何操作系统都能运行 Java 代码
- 语言无关性： JVM 能运行除 Java 以外的其他代码

Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由 JVM 执行 .class 文件，从而程序开始运行。

JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器 都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。

> Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。

## Class 文件结构

Class 文件是一组以 8字节为单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有任何分隔符与空格，整个 Class 文件的内容几乎是程序运行的必要数据。Class 文件中的所有内容被分为两种类型：无符号数、表。 

- 无符号数：符号数属于基本的数据类型。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。 无符号数可以描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。
- 表： 表是由多个无符号数或者其他表作为数据项构成的符合数据类型。 

Class 文件具体由以下几个构成:

- 魔数与 Class版本信息
- 常量池
- 访问标志
- 类索引、父类索引、接口索引集合
- 字段表集合
- 方法表集合
- 属性表集合

### 魔数与 Class版本信息

Class 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型。 

Class 文件的魔数是用 16 进制表示的“CAFE BABE” 。魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。 

紧接着魔数的 4 个字节是版本信息，5-6 字节表示次版本号，7-8 字节表示主版本号，它们表示当前 Class 文件中使用的是哪个版本的 JDK。Java 版本号是从45开始的，如 JDK1.0 是45.0。

高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件。 

### 常量池

版本信息之后就是常量池，是占用 Class 文件空间最大数据项目之一，是表类型数据项目。

常量池中存储两种类型的常量：

- **字面量**，如文本字符串、声明为 final 的常量值等
- **符号引用**：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符

常量池特点：

- 常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。常量池的容量计数是从1开始的，如容量22，代表有21项常量，索引范围为 1~21
- 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。 

常量池中常量类型

| 类型                             | tag  | 描述                   |
| -------------------------------- | ---- | ---------------------- |
| CONSTANT_utf8_info               | 1    | UTF-8编码的字符串      |
| CONSTANT_Integer_info            | 3    | 整型字面量             |
| CONSTANT_Float_info              | 4    | 浮点型字面量           |
| CONSTANT_Long_info               | 5    | 长整型字面量           |
| CONSTANT_Double_info             | 6    | 双精度浮点型字面量     |
| CONSTANT_Class_info              | 7    | 类或接口的符号引用     |
| CONSTANT_String_info             | 8    | 字符串类型字面量       |
| CONSTANT_Fieldref_info           | 9    | 字段的符号引用         |
| CONSTANT_Methodref_info          | 10   | 类中方法的符号引用     |
| CONSTANT_InterfaceMethodref_info | 11   | 接口中方法的符号引用   |
| CONSTANT_NameAndType_info        | 12   | 字段或方法的符号引用   |
| CONSTANT_MethodHandle_info       | 15   | 表示方法句柄           |
| CONSTANT_MethodType_info         | 16   | 标识方法类型           |
| CONSTANT_InvokeDynamic_info      | 18   | 表示一个动态方法调用点 |

对于 CONSTANT_Class_info（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下： 

| 类型 | 名称       | 数量 |
| ---- | ---------- | ---- |
| u1   | tag        | 1    |
| u2   | name_index | 1    |

tag 是标志位，用于区分常量类型；name_index 是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为 0x0002，也即是指向了常量池中的第二项常量。 

CONSTANT_Utf8_info 型常量的结构如下：

| 类型 | 名称   | 数量   |
| ---- | ------ | ------ |
| u1   | tag    | 1      |
| u2   | length | 1      |
| u1   | bytes  | length |

tag 是当前常量的类型；length 表示这个字符串的长度；bytes 是这个字符串的内容（采用缩略的 UTF8 编码）

### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract修饰。如果是类，是否声明为 final。 

### 类索引、父类索引、接口索引集合

类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。除了 Object 类外，所有 Java 类的父索引都不为 0。

一个类可能实现了多个接口，因此用接口索引集合来描述。这个集合第一项为 u2 类型的数据，表示索引表的容量，接下来就是接口的名字索引。 顺序按照代码从左到右的声明顺序。

类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。 

### 字段表集合

字段表用于描述接口或类中声明的变量，包括实例变量和类变量，但不包括方法中的局部变量。 

每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。字段表结构如下：

| 类型           | 名称             | 数量             | 说明                                                         |
| -------------- | ---------------- | ---------------- | ------------------------------------------------------------ |
| u2             | access_flags     | 1                | 字段的访问标志，与类稍有不同                                 |
| u2             | name_index       | 1                | 字段名字的索引                                               |
| u2             | descriptor_index | 1                | 描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。 |
| u2             | attributes_count | 1                | 属性表集合的长度                                             |
| attribute_info | attributes       | attributes_count | 属性表集合，用于存放属性的额外信息，如属性的值。             |

> 字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 

Java 语言中字段是无法重载的，必须使用不同的名字。但是对字节码来说，如果两个字段的描述符不一致，那么字段重名是合法的。

### 方法表集合

方法表结构与属性表类似。

volatile 关键字 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 ACC_VOLATILE 和 ACC_TRANSIENT 标志。

方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令。

> 如果父类方法没有被子类重写，方法表集合中不会出现来自父类的方法信息。但有可能出现编译器自动添加的方法，如类构造器  “&lt;clinit&gt;”  和实例构造器  “&lt;init&gt;” 方法。

Java 语言中，重载方法要求方法拥有不同的特征签名。特征签名就是一个方法中各个**参数**在常量池中的字段符号引用的集合，不包括返回值。因此 Java 语言无法通过返回值重载函数。但是在 Class 文件中，只要**描述符**不一致的两个方法可以共存，即方法返回值不同可以共存于 Class文件中。

### 属性表集合

在 Class文件、字段表、方法表都携带着属性表集合，用于描述场景专有的信息。每个属性对应一张属性表，属性表的结构如下：

| 类型 | 名称                 | 数量             |
| ---- | -------------------- | ---------------- |
| u2   | attribute_name_index | 1                |
| u4   | attribute_length     | 1                |
| u1   | info                 | attribute_length |

1. Code 属性：出现在方法表的属性集合中，存储字节码指令
2. Exception 属性：出现在方法表，列举方法中可能抛出的受检查异常，即 throws 后面的异常
3. LineNumberTable 属性：描述 Java 源码行号与字节码行号（字节码偏移量）的对应关系
4. LocalVariableTable 属性：描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系
5. SourceFile 属性：记录生成这个 Class 文件的源码文件名称
6. ConstantValue 属性：存在字段表中，作用是通知虚拟机自动为静态变量赋值。
7. InnerClasses 属性：记录内部类与宿主类之间的关联
8. Deprecated 属性：表示类、方法或字段不再推荐使用
9. Synthetic 属性：表示此字段或方法不是由 Java源码直接产生，而是编译器自行添加的
10. StackMapTable 属性：是复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用
11. Signature 属性：记录泛型签名信息
12. BootstrapMethods 属性：用于保存 invokedynamic 指令引用的指导方法限定符