# 类加载过程

类加载过程包括：加载、验证、准备、解析、初始化。

## 加载

### 加载过程

“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成 3 件事： 

- 通过类的全限定名获取该类的二进制字节流。 
- 将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。 

- 在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 

### 获取二进制字节流

对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：

- 从 zip 包中读取，如 jar、war等
- 从网络中获取，如 Applet
- 通过动态代理生成代理类的二进制字节流
- 由 JSP 文件生成对应的 Class 类
- 从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。

### 数组类与非数组类的加载

非数组类的加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字符流的获取方式（即重写类加载器的 loadClass() 方法）。

数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但是数组类的元素类型最终是要靠类加载器去创建的，一个数组类创建过程遵循以下规则：

- 如果数组的组件类型是引用类型，那就递归采用本节定义的加载过程去加载这个组件类型，数组类将在加载该组件类型的类加载器的类名称空间上被标记。
- 如果数组的组件类型不是引用类型（如 int[] 类型），Java 虚拟机会讲数组类标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为 public。

### 其他

加载阶段完成后，虚拟机外部的二进制字节流按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。然后在内存实例化一个 java.lang.Class 类对象（没有明确在 Java 堆中）。对于 HotSpot 虚拟机，Class 对象存储在方法区，作为程序访问方法区中的类型数据的外部接口。

加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始实践仍然保持着固定的先后顺序。 

## 验证

验证是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。

验证阶段大致有4个验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

### 文件格式验证

验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。可能包括以下验证点：

- 魔数 0xCAFEBABE 开头
- 主次版本号是否能在本虚拟机处理
- 常量池的常量是否有不被支持的常量类型（检查常量 tag 标志）
- 指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量
- CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据
- .......

这个阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储。而往后的3个阶段的验证是基于方法区的存储结构进行的，不直接操作字节流。

### 元数据验证

对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。验证包括：

- 这个类是否有父类（除 Object 类之外，所有类都有父类）
- 这个类的父类是否被 final 修饰
- 如果非抽象类，是否实现了父类要求实现的所有方法
- 类的字段、方法是否与父类有矛盾
- ......

### 字节码验证

通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。即对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。例如：

- 保证操作数栈的数据类型与指令代码序列能配合工作，如不会出现操作数栈放了 int 类型数据，而按 long 类型加载如本地变量表
- 保证跳转指令不会跳转到方法体以外的字节码指令
- 保证方法体中的类型转换是有效的

JDK1.6 后，方法体的 Code 属性添加了 StackMapTable 属性，描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态。在字节码验证期间，只要检查 StackMapTable 属性的记录是否合法即可。

### 符号引用验证

符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，转化动作在解析阶段中进行。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常包括：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的访问性是否可以被当前类访问

符号引用验证的目的是确保解析动作能够正常执行。

对于虚拟机的类加载机制而言，验证阶段是非常重要的，但不是一定必要的阶段。

## 准备

准备阶段是正式为类变量（static 修饰的变量）分配内存并设置类变量初始值的阶段，这些变量在方法区进行分配。

初始值 “通常情况下” 是数据类型的零值（0, null...），假设一个类变量的定义为：

```java
public static int value = 123;
```

那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器 `<clinit>()` 方法中，所以赋值 123 的动作在初始化阶段才会进行。

存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：

```java
public static final int value = 123;
```

那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。

## 解析

解析是虚拟机将常量池内的符号引用替换为直接引用的过程。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符。

### 接口或类的解析

假设当前类为D，将符号引用N 解析为类或接口C 的直接引用，步骤为：

1. 如果C 不是数组类型，会将代表 N 的全限定名传递给 D 的类加载器去加载类 C。可能触发其他相关类的加载，如加载类的父类或实现接口。
2. 如果C 是数组类型，并且数组的组件类型是对象，即 N 是 "[L 全限定名" 的形式，那将会按照第一点的规则加载数组元素类型。
3. 解析完成之前还要进行符号引用验证，确认 D 是否具备对 C 的访问权。

### 字段解析

要解析字段的符号引用，需要先对字段所属的类或接口的符号引用进行解析。这个字段所属的类或接口用 C 表示，对 C 进行后续字段的搜索：

1. 如果 C 本身包含了简单名称和字段描述符都与目标匹配的字段，直接返回字段的直接引用，查找结束。
2. 否则，如果在 C 实现了接口，会按照继承关系从下往上递归搜索各个接口和它的父接口。
3. 否则，如果不是 Object 类的话，会按照继承关系从下往上递归搜索其父类。
4. 否则，查找失败，抛出 java.lang.NoSuchFieldError 异常。

如果查找成功返回了引用，还要对这个字段进行权限验证。

### 类方法解析

要解析类方法的符号引用，需要解析出类方法表的 class_index 项中索引的方法所属的类或接口的符号引用。同样用 C 表示类，后续步骤：

1. 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表发现 C 是接口，直接抛出异常。
2. 在类 C 中查找是否有简单名称和描述符与目标匹配的方法，有则返回方法的直接引用，查找结束。
3. 否则，在父类中递归查找。
4. 否则，在类C 实现的接口列表和它们的父接口中递归查找。如果存在匹配，说明类C 是一个抽象类，此时查找结束，并抛出 java.lang.AbstractMethodError 异常。
5. 否则，查找方法失败，抛出 java.lang.NoSuchMethodError 异常。

如果查找成功返回了引用，还要对这个方法进行权限验证。

### 接口方法解析

要解析接口方法的符号引用，需要解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用。同样用 C 表示接口，后续步骤：

1. 如果接口方法表中的 class_index 中的索引 C 是类，直接抛出异常。
2. 在接口 C 中查找是否有简单名称和描述符与目标匹配的方法，有则返回方法的直接引用，查找结束。
3. 否则，在接口C 的父接口中递归查找，直至 Object 类为止。
4. 否则，查找方法失败，抛出 java.lang.NoSuchMethodError 异常。

接口中的所有方法默认是 public 的，不存在访问权限的问题。

## 初始化

类初始化阶段是类加载过程的最后一步，是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，即执行类构造器 `<clinit>()` 方法的过程。 

- `<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。 

- 静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：

```java
public class Test {
    static {
        i = 0;  // 给变量赋值可以正常编译通过
        System.out.println(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

- `<clinit>()` 方法不需要显式调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。 即第一个执行该方法的一定是 Object 类。
- 由于父类的 `<clinit>()` 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示： 

```
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
    System.out.println(Sub.B); // 输出 2
}
```

- `<clinit>()` 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。 
-  接口中不能使用静态代码块，但接口也需要通过 `<clinit>()` 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 `<clinit>()` 方法不需要先执行父类的 `<clinit>()` 方法，只有当父接口中定义的变量使用时，父接口才会初始化。 
-  虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法。 